################################# flowVC INPUT FILE #####################################
#
# NOTE: Order of parameters listed must be maintained for proper parsing of input file
#	Comment lines begin with #, comments can be added or removed as desired
#	Standard format: VARIABLE_NAME = VALUE
#
###################################################################################
# pts all over the domain, released once, outputTres increased
# Path_Data: String, Directory containing data files
# Can be set to pwd (i.e. present working directory)
Path_Data = /scratch/bkm82/ECMO/input
# Path_Output: String, Directory where output files will be written
# Can be set to pwd (i.e. present working directory)
Path_Output = /scratch/bkm82/ECMO/med_back/ftle_data/output/med_b1

# Dimensions: Integer, Specifies if velocity data is 2D or 3D
Dimensions = 3

# Data_MeshType: Integer, Specifies mesh type of velocity data
# 0: Cartesian
# 1: Unstructured static mesh (tetrahedral for 3D and triangular for 2D)
# 2: Unstructured moving mesh
Data_MeshType = 1

# Data_InFilePrefix: String, common prefix for input files
# (e.g. velocity, adjacency, connectivity, coordinate files)
Data_InFilePrefix = interpolated_velocity

# Data_SuffixTMin: Integer, number appended to the name of first velocity data file
# Assumes naming convention of Data_InFilePrefix_vel.N.bin, where Data_InFilePrefix is
# specified above and N varies from Data_SuffixTMin
Data_SuffixTMin = 1200

# Data_SuffixTDelta: Integer, Increment between successive velocity data files
Data_SuffixTDelta = 5

# Data_SuffixTRes: Integer, number of velocity data files
Data_TRes = 21

# Data_TDelta: (Positive) Float, "Real" time spacing between successive velocity data files
# Assumes time spacing between velocity data files is constant
Data_TDelta = 0.05

# Data_TMin: Float, Absolute time assigned to first velocity data file
# Choice is arbitrary, but it usually makes sense to set this to zero, which in that case
# would mean that the first velocity data file specifies the velocity at time zero
Data_TMin = 0.0

# Data_TPeriodic: Binary flag, Specifies if data is periodic
# 0: Not periodic
# 1: Periodic (make sure first and last data file correspond to same point in cycle)
Data_TPeriodic = 1

#adding this to see if it resolves the issue of not reading the
Data_XPeriodic = 0
# Data_MeshBounds.XMin, ..., Data_MeshBounds.ZMax: Specifies bounding box of velocity data to consider
# Can be used to set a region for computing residence times
Data_MeshBounds.XMin = -0.07324
Data_MeshBounds.XMax = 0.061596
Data_MeshBounds.YMin = 0.11067
Data_MeshBounds.YMax = 0.238690
Data_MeshBounds.ZMin = -0.02736 
Data_MeshBounds.ZMax = 0.439045

# Fluid_Density: Float, specifies fluid density (use consistent units)
# Valid only if Particle_Radius > 0
Fluid_Density = 1.2e-3

# Fluid_Viscosity: Float, specifies fluid viscosity (use consistent units)
# Valid only if Particle_Radius > 0
Fluid_Viscosity = 1.81e-4

# Output_TStart: Float, initial time to start simulation and begin writing output
# If FTLE_Compute: Specifies time at which first FTLE field is generated
# If Trace_Compute: Specifies start time to begin integrating tracer trajectories and outputing position to file
Output_TStart = 0.0

# Output_TRes: (Positive) Integer, Desired number of output times
# If FTLE_Compute: Specifies number of time instances when the FTLE field will be computed and output
# If Trace_Compute: Specifies number of time instances that tracer positions will be written to file
Output_TRes = 21

# Output_TDelta: (Positive) Float, Desired time between successive output
# If FTLE_Compute: How often the FTLE field will be computed and output
# If Trace_Compute: How often the tracer positions will be output
Output_TDelta = 0.05

# Int_Type: Integer, specified integration routine used
# If Particle_Radius > 0 ==> Euler integration method is taken automatically
# Runge Kutta methods are integration option for ideal tracers without mass
# 0: Euler
# 1: 4th order Runge Kutta
# 2: Runge Kutta Fehlberg (adaptive time stepping)
Int_Type = 1

# Int_BMR: flag (Backward Maxey-Riley [BMR] resembles solving Maxey-Riley equation backward in time)
# 0: Integrate the trajectories via traditional method by solving Maxey-Riley equation
# 1: Integrate the trajectories by solving motion equation on slow manifolds
#Int_BMR = 0

# Int_TimeStep: (Positive) Float, Time step used for integration Euler or RK4 routines (i.e. Int_Type = 0 or 1)
# Valid only for Int_Type = 0 or 1
# Int_TimeStep = 5e-4 # not useful when doing particle deposition 
#Int_TimeStep = 1e-5 # good in case of steady simulation
 Int_TimeStep = 5e-6 # good while doing unsteady simulations
# Int_TimeStep = 5e-7 # high resolution

# Int_Accuracy: (Positive) Float, Absolute error tolorance (between RK4 and RK5)
# Valid only for Int_Type = 2
Int_Accuracy = 0.0001

# Int_MinTimeStep: (Positive) Float, Minimum allowable time step used in RKF routine
# Once this time step is reached, RK4 approximation automatically accepted
# Valid only for Int_Type = 2
Int_MinTimeStep	= 0.0001

# Int_MaxTimeStep: (Positive) Float, Maximum allowable time step used in RKF routine
# Used as initialize guess for suitable time step when RKF routine is called
# Time step will not be increased beyond this limit even if error between RK4 and RK5 is less than Int_Accuracy
# Valid only for Int_Type = 2
Int_MaxTimeStep	= 0.001

# Int_TimeDirection: Integer, Should be set to 1 or -1
#  1: Advect particles forward in time
# -1: Advect particles backward in time (used to compute backward time FTLE field)
Int_TimeDirection = -1

# Int_NormalFlow: flag
# 0: Do not impose inward flow on no-slip boundaries
# 1: Replace no-slip condition on boundaries with inward velocity (magnitude specified by NormalFlowScaling)
# 2: Capture particles once their distance to wall is less than a threshold (Distance_Threshold) [painfully slow]
# Currently valid only for Data_MeshType = 1 and Dimensions = 3
Int_NormalFlow = 0

# Int_NormalFlowScaling: (Positive) Float, Scaling for inward pointing boundary velocity (to prevent tracers from crossing
# no-slip boundaries)
# Valid only for Dimensions = 3, Data_MeshType = 1 or 2, Int_NormalFlow = 1
Int_NormalFlowScaling = 0.05   

#Int_Extrapolate: Integer, allows particles to be integrated outside of domain of data by extrapolation of data set
#  0: End integration once particle leaves domain
#  1: Extrapolate velocity outside domain by continuing particle with exit velocity
#  2: Linear extrapolation of entire data set
Int_Extrapolate = 0

# Distance_Threshold:  (Positive) Float, Specify a threshold for capturing particles by the distance to wall
# A conservative assumption is .4D
# Over .5D(=R) does not make any physical sense!
# Valid only if Int_NormalFlow = 2
#Distance_Threshold = 12e-5

# Particle_Radius: Float, Radius of all things treated as Lagrangian points
# Set to zero if you want points to behave as perfect tracers
Particle_Radius = 0.0

# Particle_Density: Float, Mass density of all things treated as Lagrangian points
# Respectively, set =, >, or < fluid density for neutrally buoyant, aerosols, or bubbles
# Only valid if Particle_Radius > 0
Particle_Density = 1.0

# Particle_ICType: Int, Specified type of initial condition assigned to particles
# 0: Start particles from rest
# 1: Start particles with velocity equal to fluid velocity at particle release location
# Valid only if Particle_Radius > 0
Particle_ICType = 0

# Gravity_Vector[i]: Floats, Specifies components of gravity vector (use consistent units)
# Valid only if Particle_Radius > 0
# VERY VERY IMPORTANT WHILE DOING PARTICLE TRACKING! BE CAREFUL OF THE DIRECTIONS (+?-)
Gravity_Vector[0] = 0
Gravity_Vector[1] = 0
Gravity_Vector[2] = -981

# Local_Search_Checking: Binary flag
# 0: Only use local search protocol to determine elements containing initial location of points
#    where velocity will need to be interpolated (fastest)
# 1: Use global search to check failures of local search protocol (safest, but painfully slow if many points located
#    outside of the domain)
# Valid only if Data_MeshType = 1 or 2
LocalSearchChecking = 0

# FTLE_Compute: Binary flag
# 0: Do not compute FTLE fields
# 1: Compute FTLE fields (Trace_Compute must be 0)
FTLE_Compute = 1

# FTLE_GenerateMesh: Binary flag
# 0: Read in FTLE mesh data from file FTLE_ICFile (this file created by running flowVC with FTLE_GenerateMesh = 1)
# 1: Generate a Cartesian mesh over which FTLE will be computed (mesh parameters specified below, resulting data
#    saved to file FTLE_ICFile)
# Valid only if FTLE_Compute = 1
FTLE_GenerateMesh = 1

# FTLE_ICFile: String, Name of file storing FTLE mesh information
# If FTLE_GenerateMesh = 0, this file should be located in Path_Work directory
# If FTLE_GenerateMesh = 1, this file will be written to Path_Work directory
# Valid only if FTLE_Compute = 1
FTLE_ICFile = FTLE_mesh.bin

# FTLE_MeshBounds.XMin, ..., FTLE_MeshBounds.ZRes: Specifies structured grid over which FTLE is computed
# Valid only if FTLE_Compute = 1
#delta_x = (Xmax - Xmin) / (Xres-1)   we need delta_x=delta_y=delta_z
FTLE_MeshBounds.XMin = -0.07324
FTLE_MeshBounds.XMax = 0.061596
FTLE_MeshBounds.YMin = 0.11067
FTLE_MeshBounds.YMax = 0.238690
FTLE_MeshBounds.ZMin = -0.02736
FTLE_MeshBounds.ZMax = 0.439045
FTLE_MeshBounds.XRes = 202
FTLE_MeshBounds.YRes = 188
FTLE_MeshBounds.ZRes = 690

# FTLE_IntTLength: (Positive) Float, Integration time used to compute FTLE
# Valid only if FTLE_Compute = 1
FTLE_IntTLength = 1.0 #cardiac cycle duration

# FTLE_ComputeVariation: Binary flag
# 0: Compute FTLE at each output time with integration time set to FTLE_IntTimeLength
# 1: Compute variation of FTLE with integration time
# Output_TRes should be 1 if FTLE_ComputeVariation = 1
# Valid only if FTLE_Compute = 1
FTLE_ComputeVariation = 0

# FTLE_VariationOutFreq: (Positive) Integer, controls how often FTLE is output when computing variation of FTLE with
# integration time
# If set to one, output is generated at every time instance that velocity data is defined, if set to say 5, then output
# is generated at 1/5 of that rate (i.e. every 5 velocity data frames)
# Valid only if FTLE_ComputeVariation = 1
FTLE_VariationOutFreq = 1

# FTLE_OutFilePrefix: String, Filename prefix where FTLE output data is written
# A separate file is generated for each output time
# Valid only if FTLE_Compute = 1
FTLE_OutFilePrefix = FTLEbwd_

# Trace_Compute: Binary flag
# 0: Do not compute tracer trajectories
# 1: Compute tracer trajectories (FTLE_Compute must be 0)
Trace_Compute = 0

# Trace_ReleaseStrategy: Integer flag
# 0: Traditional release based on launch time parameters below
# 1: Staggered release based on flow rate
# Valid only if Trace_Compute = 1 and (currently) for Data_MeshType = 1 and Dimensions = 3
Trace_ReleaseStrategy = 0

# Trace_ReleaseTMax: (Positive) Float, how long to generate staggered release
# Valid only if Trace_Compute = 1 and Trace_ReleaseStrategy = 1
Trace_ReleaseTMax = 0.000755

# Trace_GenerateMesh: Binary Flag
# 0: Read in tracer initial positions from a file (specified by Trace_InFile)
# 1: Generate a Cartesian mesh of tracers to integrate (mesh parameters specified below)
# Valid only if Trace_Compute = 1 and Trace_ReleaseStrategy = 0
Trace_GenerateMesh = 0

# Trace_InFile: String, Name of File containing tracer initial positions
# Valid only if Trace_Compute = 1 and Trace_GenerateMesh = 0
# inlet1 : initially 1,225 particles with spacing 0.04 at main inlet (it might get updated!)
# inlet2 : initially 4,889 particles with spacing 0.02 at main inlet (it might get updated!)
# inlet3 : initially 19,597 particles with spacing 0.01 at main inlet (it might get updated!)
# inlet4 : initially 40,009 particles with spacing 0.007 at main inlet (it might get updated!)
# inlet_1mil : initially 1,014,218 particles with spacing 0.00139 at main inlet (it might get updated!)
# inlet5 : initially 542,807 particles with spacing 0.0019 at main inlet (it might get updated!)
# inlet6 : initially 253,553 particles with spacing 0.0019 at main inlet (it might get updated!)
# inlet7 : initially 100,314 particles with spacing 0.00443 at main inlet (it might get updated!)
# RML_1 : initially 69,315 particles with spacing 0.0025 at RML inlet (it might get updated!)
# trachea_1 : initially 128,924 particles with spacing 0.004 at trachea inlet (it might get updated!)
Trace_InFile = trachea_1.vtk 

# Trace_MultipleInFiles: Binary Flag
# 0: Default
# 1: Tracer initial conditions change over time and are specified by multiple files
Trace_MultipleInFiles = 0

# Trace_InFileFormat: Integer, specifies format of Trace_InFile
# 0: Use this if you want to reuse the .IC file that is generated from flowVC (use with care)
# 1: ASCII file, first line lists the number of tracers and subsequent lines list the coordinates
# 2: ASCII legacy VTK polydata mesh format (as output from Paraview)
# 3: ASCII legacy VTK unstructured mesh format (as output from Paraview)
# 4: Binary file, first entry lists number of points and subsequent entries list coordinates of points
# If set to 1, residence time data will be output as unstructured mesh
# Valid only if Trace_Compute = 1, Trace_ReleaseStrategy = 0 and Trace_GenerateMesh = 0
Trace_InFileFormat = 4

# Trace_OutFile: String, Prefix of files where tracer position data will be written
# Tracer positions written to separate files for each output time
# Valid only if Trace_Compute = 1
Trace_OutFilePrefix = trachea_1_5e-5

# Trace_NumLaunchTimes: (Positive) Integer, Number of times to release tracers from initial positions
# Valid only if Trace_Compute = 1 and Trace_ReleaseStrategy = 0
Trace_NumLaunchTimes = 1

# Trace_LaunchTimeSpacing: (Positive) Float, Time between successive release of tracers from starting locations
# Valid only if Trace_Compute = 1, Trace_ReleaseStrategy = 0 and Trace_NumLaunchTimes > 1
Trace_LaunchTimeSpacing = 0.02

# Trace_IntTLength: (Positive) Float, Limits amount of time any tracer will be integrated
# Useful when computing the residence time field at more than one point in time, that is
# to ensure all releases are integrated the same length of time
# Valid only if Trace_Compute = 1 and Trace_ReleaseStrategy = 0
Trace_IntTLength = 1000   # 3 cardiacs

# Trace_AlwaysOutput: Binary Flag
# 0: Do not write out tracer position to file once it has left the domain
# 1: Always write out tracer position to file, even if it left the domain
# Valid only if Trace_Compute = 1
Trace_AlwaysOutput = 1

# Trace_MeshBounds.XMin, ..., Trace_MeshBounds.ZRes: Specifies Cartesian mesh of tracers to be intergrated
# Valid only if Trace_Compute = 1 AND Trace_GenerateMesh = 1   #spacing = .075  , 34682 integrated for.1
Trace_CartMesh.XMin = -1.9
Trace_CartMesh.XMax =  .43 
Trace_CartMesh.YMin = -11.3
Trace_CartMesh.YMax = -9.7
Trace_CartMesh.ZMin = 26.1 
Trace_CartMesh.ZMax = 26.3
Trace_CartMesh.XRes = 200
Trace_CartMesh.YRes = 200
Trace_CartMesh.ZRes = 4

######
Trace_VorticityCompute = 0 

# Trace_APCompute: Binary flag
#    Requires Data_InFilePrefix_strain-rate.#.bin files.
# 0: Do not compute
# 1: Compute activation potential (integrated strain rate) for each particle.
# Valid only if Tracer_Compute = 1
Trace_APCompute = 0

# Trace_ComputeCET: Binary flag
# 1: Compute exposure time data for elements in velocity mesh using the tracer paths
# 0: Do not compute exposure time data
# Valid only if Tracer_Compute = 1 and NOT VALID for Trace_ComputeRT = 1
Trace_CETCompute = 0

# Trace_CETAuxillaryMesh: Binary flag
# 1: Use an auxillary mesh for CET computations, specificed by Trace_CETAuxillaryMeshPrefix
# 0; Use velocity field mesh for CET computations
# Valid only for Trace_Compute = 1 and Trace_ComputeCET = 1
Trace_CETAuxillaryMesh = 1

# Trace_CETAuxillaryMeshPrefix: String
# Prefix for files containing coordinates, connectivity and adjacency data for auxillary mesh
Trace_CETMeshPrefix = meshfile #AMIR

# Trace_CETSubsteps: Integer, numer of intervals used to discretize exposure time contributions when particle path
# intersects multiple elements during a single integration time step
# Valid only for Tracer_Compute = 1 and Trace_ComputeCET = 1
Trace_CETSubsteps = 50

# Trace_ComputeRT: Binary flag
# 0: Do not compute residence time
# 1: Compute residence time of tracers
# Will compute output for Trace_NumLaunchTimes
# Valid only if Tracer_Compute = 1 and NOT VALID for Trace_ComputeCET = 1
Trace_RTCompute = 0 #AMIR

# Trace_RTOutFilePrefix: String, Filename prefix for residence time or exposure time computations
# Valid only if Trace_Compute = 1 and Trace_ComputeCET = 1 or Trace_ComputeRT = 1
Trace_RTOutFilePrefix = AAA18rt

# VelOut_Compute: Binary flag, Used to generate interpolated velocity fields
# 0: Do not generate interpolated velocity fields
# 1: Generate interploated velocity fields
VelOut_Compute = 0

# VelOut_GenerateMesh: Binary flag
# 0: Read interpolation locations from file specified by VelOut_InFile
# 1: Generate a Cartesian mesh of positions where velocity will be interpolated (mesh parameters specified below)
# Valid only for VelOut_Compute = 1
VelOut_GenerateMesh = 1

# VelOut_InFile: String, filename containing locations of points for interpolation
# Valid only for VelOut_Compute = 1 and VelOut_GenerateMesh = 0
VelOut_InFile = transient-interpolated.vtk

# VelOut_InFileFormat, Integer, specified format of VelOut_InFile
# 1: ASCII file, first line lists the number of locations and subsequent lines list the coordinates
# 3: ASCII legacy VTK polydata mesh format (as output from Paraview)
# 4: ASCII legacy VTK unstructured mesh format (as output from Paraview)
# Valid only if VelOut_Compute = 1 AND VelOut_GenerateMesh = 0
VelOut_InFileFormat = 1

# VelOut_FilePrefix: String, Filename prefix for files that interpolated velocity is data is written to
# Velocity output written to separate files, one per output time
# Valid only if VelOut_Compute = 1
VelOut_FilePrefix = transient-interpolated

# VelOut_MeshBounds.XMin, ..., VelOut_MeshBounds.ZRes: Specifies Cartesian mesh of interpolation positions
# Valid only if VelOut_Compute = 1
VelOut_CartMesh.XMin = -3.0
VelOut_CartMesh.XMax = 6.0
VelOut_CartMesh.YMin = -1.577
VelOut_CartMesh.YMax = 1.577
VelOut_CartMesh.ZMin = 0.0
VelOut_CartMesh.ZMax = 0.0
VelOut_CartMesh.XRes = 91
VelOut_CartMesh.YRes = 32
VelOut_CartMesh.ZRes = 1
